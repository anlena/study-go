[原文地址](https://yuchengkai.cn/docs/zh/frontend/##%E4%B8%BA%E4%BB%80%E4%B9%88-01--02--03)

### js

* #### 内置类型

  JS中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象(Object).

  基本类型有六种:null、undefined、number、string、boolean、symbol.

  其中JS的数字类型是浮点类型的，没有整型。并且浮点类型基于IEEE 754实现，在使用中会遇到某些bug。NaN也属于number类型，并且NaN不等于自身。

  对于基本类型来说，如果使用字面量的方式，那么这个字面量只是个字面量，只有在必要的时候才会转换为对应的类型

  ```js
  let a = 111;	//这只是字面量，不是number类型
  a.toString();	//使用时候才会转换为对象类型
  ```

  对象(Object)是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。

  ```js
  let a = {name:'FE'};
  let b = a;
  b.name = 'EF';
  console.log(a.name);	//EF
  ```

* #### TypeOf

  typeof对于基本类型，除了null都可以显示正确的类型

  ```js
  typeof 1 //	'number'
  typeof '1'	// 'string'
  typeof undefined // 'undefined'
  typeof true //	'boolean'
  typeof Symbol()	//	'symbol'
  typeof b	//b没有声明，但是还会显示undefined
  ```

  typeof对于对象，除了函数都会显示object

  ```js
  typeof [] // 'object'
  typeof {}	//	'object'
  typeof console.log	//	'function'
  ```

  对于null来说，虽然它是基本类型，但是会显示object,这是一个存在了很久了的Bug。

  ```js
  typeof null	//	'object'
  ```

  PS:为什么会出现这种情况呢？因为在JS的最初版本中，使用的是32位系统，为了性能考虑使用低位存储了变量的类型信息，000开头代表是对象，然而null表示为全零，所以将它错误的判断为object。虽然现在的内部类型判断代码已经改变了，但是对于这个Bug确是一直流传下来。

  如果我们想获得一个变量的正确类型，可以通过Object.prototype.toString.call(xx)。这样我们就可以获得类似[Object Type]的字符串。

  ```js
  let a 
  //我们也可以这样判断 undefined
  a === undefined
  //但是undefined不是保留字，能够在低版本浏览器被赋值
  let undefined = 1
  //这样就会报错
  //所以可以用下面的方式来判断，并且代码量更少
  //因为void后面随便跟上一个组成表达式
  //返回就是undefined
  a === void 0
  ```

* #### 类型转换

  ##### 转Boolean

  在条件判断时，除了undefined,null,false,NaN,'',0,-0,其他所有值都转换为true,包括所有对象。

  ##### 对象转基本类型

  对象在转换基本类型时，首先会调用valueOf然后toString。并且这两个方法你是可以重写的。

  ```js
  let a = {
      valueOf(){
          return 0;
      }
  }
  ```

  当然你也可以重写Symbol.toPrimitive,该方法在转基本类型时调用优先级别最高。

  ```js
  let a = {
      valueOf(){
          return 0;
      },
      toString(){
          return '1';
      },
      [Symbol.toPrimitive](){
          return 2;
      }
  }
  1 + a // => 3
  '1' + a //	=> '12'
  ```

  ##### 四则运算符

  只有当加法运算时，其中一方是字符串类型，就会把另一个也转换为字符串类型。其他运算只要其中一方是数字，那么另一方就转为数字。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。

  ```js
  1 + '1'	//'11'
  2 * '2'	//	4
  [1,2] + [2,1]	//	'1,22,1'
  //[1,2].toString() -> '1,2'
  //[2,1].toString() -> '2,1'
  //'1,2' + '2,1' = '1,22,1'
  ```

  对于加号需要注意这个表达式'a' + + 'b'

  ```
  'a' ++ 'b'
  //因为 + 'b' -> NaN
  //你也许在一些代码中看到过 + '1' -> 1
  ```

  ##### ==操作符

  比较运算符x==y,其中x和y是值，产生true或者false。这样的比较按如下方式进行：

  1. 若Type(x)与Type(y)相同，则

     1. 若Type(x)为Undefined,返回true,
     2. 若Type(x)为Null,返回false。
     3. 若Type(x)为Number，则
        1. 若x为NaN,则返回false
        2. 若y为NaN,则返回false
        3. 若x与y为相等数值，返回true
        4. 若x为+0且y为-0，返回true
        5. 若x为-0且y为+0，返回true
        6. 返回false
     4. 若Type(x)为String，则当x和y为完全相同的字符串列(长度相等且相同字符在相同位置)时返回true。否则，返回false。
     5. 若Type为Boolean，当x和y为同为true或者同为false时返回true。否则，返回false。

  2. 若x为null且y为undefined，返回true。

  3. 若x为undefined且y为null，返回true。

  4. 若Type(x)为Number且Type(y)为String,返回comparison x == ToNumber(y)的结果。

  5. 若Type(x)为String,且Type(y)为Number,返回比较ToNumber(x) == y的结果。

  6. 若Type(x)为Boolean，返回比较ToNumber(x) === y的结果。

  7. 若Type(y)为Boolean，返回比较x === ToNumber(y)的结果。

  8. 若Type(x)为String或Number，且Type(y)为Object,返回比较x === ToPrimitive(y)的结果。

  9. 若Type(x)为Object且Type(y)为String或Number,返回比较ToPrimitive(x) == y的结果。

  10. 返回false。

      

  上面的toPrimitive就是对象转基本类型。

  这里来解析一道题目	 [] == ![] 	// -> true,下面是这个表达式为为何为`true` 步骤

  ```js
  // []转换成true,然后取反变成false
  [] == false
  //根据第8条得出
  [] == ToNumber(false)
  [] == 0
  //根据第10条得出
  ToPrimitive([]) == 0
  //[].toString() -> ''
  '' == 0
  //根据第6条得出
  0 == 0	// —> true
  ```

  ##### 比较运算符

  1. 如果是对象，就通过`toPrimitive`转换对象
  2. 如果是字符串，就通过`unicode`字符来比较

  

  #### 原型

  ![prototype](https://camo.githubusercontent.com/71cab2efcf6fb8401a2f0ef49443dd94bffc1373/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f332f31332f313632316538613962636230383732643f773d34383826683d35393026663d706e6726733d313531373232) 

  每个函数都有`prototype`属性，除了`Function.prototype.bind()`,该属性指向原型。

  每个对象都有`_proto_`属性，指向了创建该对象的构造函数的原型。其实这个属性指向了`[[prototype]]`,但是`[[prototype]]`是内部属性，我们并不能访问到，所以使用`_proto_`来访问。

  对象可以通过`_proto_`来寻找不属于该对象的属性，`_proto_`将对象连接起来组成了原型链。

  如果你想更进一步的了解原型，可以仔细阅读 [深度解析原型中的各个难点](https://github.com/KieSun/Blog/issues/2)。 

  

  #### new

  1. 新生成了一个对象

  2. 链接到原型

  3. 绑定this

  4. 返回新对象

     在调用`new`的过程中会发生以上四件事情，我们可以试着来自己实现一个`new`

     ```js
     function create(){
         //创建一个空的对象
         let obj = new Object();
         //获得构造函数
         let Con = [].shift.call(arguments);
         //链接到原型
         obj._proto_ = Con.prototype;
         //绑定this，执行构造函数
         let result = Con.apply(obj,arguments);
         //确保 new 出来的是个对象
         return typeof result === 'object' ? result : obj;	
     }
     ```

     对于实例对象来说，都是通过`new`产生的，无论是`function Foo()`还是`let a = {b:1}`。

     对于创建一个对象来说，更推荐使用字面量的方式来创建对象(无论性能上还是可读性)。因为你使用`new Object()`的方式创建对象需要通过作用域链一层层找到`Object`,但是你用字面量的方式就没这个问题。

     ```js
     function Foo(){}
     //function 就是个语法糖
     //内部等同于	new Function()
     let a = {b:1}
     //这个字面量也是使用了 new Object()
     ```

     对于`new`来说，还需要注意下运算符优先级。

     ```js
     function Foo(){
         return this;
     }
     Foo.getName = function(){
         console.log('1')
     }
     Foo.prototype.getName = function(){
         console.log('2');
     }
     
     new Foo.getName();	// -> 1
     new Foo().getName();	// -> 2
     ```

     ![img](https://user-gold-cdn.xitu.io/2018/4/9/162a9c56c838aa88?w=2100&h=540&f=png&s=127506) 

     从上图可以看出，`new Foo()`的优先级大于`new Foo`,所以对于上述代码来说可以这样划分执行顺序

     ```js
     new (Foo.getName())
     (new Foo()).getName();
     ```

     对于第一个函数来说，先执行了`Fun.getName()`，所以结果1;对于后者来说，先执行`new Foo()`产生了一个实例，然后通过原型链找到了`Foo`上的`getName`函数，所以结果为2。

  

  #### instanceof

  `instanceof`可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的`prototype`。

  我们也可以试着实现一下`instanceof`

  ```js
  function instanceof(left,right){
      //获得类型的原型
      let prototype = right.prototype;
      //获得对象的原型
      left = left._proto_;
      //判断对象的类型是否等于类型的原型
      while(true){
          if(left === null)
              return false;
          if(prototype === left)
              return true;
          left = left._proto_;
      }
  }
  ```

  #### this

  `this`是很多人会混淆的概念，但是其实他一点都不难，你只需要记住几个规则就可以了。

  ```js
  function foo(){
      console.log(this.a);
  }
  var a = 2;
  foo();
  
  var obj = {
      a:2,
      foo:foo
  }
  obj.foo();
  
  //以上两者情况`this`只依赖于调用函数前对象，优先级是第二个情况大于第一个情况
  
  //以下情况是优先级最高的，`this`只会绑定在`c`上，不会被任何方式修改`this`指向
  
  var c = new foo();
  c.a = 3;
  console.log(c.a);
  
  //还有就是利用call,apply,bind改变this,这个优先级仅次于new
  ```

  以上几种情况明白了，很多代码中的`this`应该没什么问题了，下面让我们看看箭头函数中的`this`

  ```js
  function a(){
      return() => {
          return () => {
              console.log(this)
          }
      }
  }
  
  console.log(a()()());
  ```

  箭头函数其实是没有`this`的，这个函数中的`this`只取决于他外面的第一个不是箭头函数的函数的`this`。在这个例子中，因为调用`a`符合前面代码中的第一个情况，所以`this`是`window`。并且`this`一旦绑定了上下文，就不会被任何代码改变。

  

  #### 执行上下文

  当执行JS代码时，会产生三种执行上下文

  * 全局执行上下文
  * 函数执行上下文
  * eval执行上下文

  每个执行上下文中都有三个重要的属性

  * 变量对象(VO)，包含变量、函数声明和函数的参数，该属性只能在全局上下文访问

  * 作用域链(JS采用词法作用域，也就是说变量的作用域是在定义时就决定了)

  * this

    ```js
    var a = 10;
    function foo(i){
        var b = 20;
    }
    foo();
    ```

    对于上述代码，执行栈中有两个上下文：全局上下文和函数`foo`上下文。

    ```js
    stack = [
        globalContext,
        fooContext
    ]
    ```

    对于全局上下文来说，VO大概是这样的

    ```js
    globalContext.VO === globe;
    globalContext.VO === {
        a:undefined,
        foo:<Function>,
    }
    ```

    对于函数`foo`来说，VO不能访问，只能访问到活动对象（AO）

    ```js
    fooContext.VO === foo.AO
    fooContext.AO {
        i:undefined,
        b:undefined,
        arguments:<>
    }
    //arguments是函数独有的对象(箭头函数没有)
    //该对象是一个伪数组，有`length`属性可以通过下标访问元素
    //该对象中的`callee`属性代表函数本身
    //`caller`属性代表函数的调用者
    ```

    对于作用域链，可以把它理解成包含自身变量对象和上级变量对象的列表，通过`[[Scope]]`属性查找上级变量

    ```
    foo
    ```

    

  



​	